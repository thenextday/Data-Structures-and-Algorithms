# 算法分析

研究算法的最终目的就是花更少的时间，如何占用更少的内存去完成相同的需求。有关算法时间耗费分析，我们称之为算法的时间复杂度分析，有关算法的空间耗费分析，我们称之为算法的空间复杂度分析。

## 1.算法的时间复杂度分析：

**事前分析估算方法：**

在计算机程序编写前，依据统计方法对算法进行估算，经过总结，我们发现一个高级语言编写的程序程序在计算机 上运行所消耗的时间取决于下列因素： 

1. 算法采用的策略和方案； 

2. 编译产生的代码质量； 

3. 问题的输入规模(所谓的问题输入规模就是输入量的多少)； 

4. 机器执行指令的速度；

由此可见，抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间依赖于算法的好坏和问题的输入规模。 如果算法固定，那么该算法的执行时间就只和问题的输入规模有关系了。

我们分析一个算法的运行时间，最重要的就是把核心操作的次数和输入规模关联起来

![image-20211004212711604](E:\Computer\学习笔记\study-notes\study_note\算法\黑马数据结构与算法\数据结构与算法资料\image-20211004212711604.png)

### 1.1.函数渐近增长

#### 1.1.1 **概念：**

给定两个函数f(n)和g(n),如果存在一个整数N，使得对于所有的n>N,f(n)总是比g(n)大，那么我们说f(n)的增长渐近 快于g(n)。 

概念似乎有点艰涩难懂，那接下来我们做几个测试。 

#### 1.1.2 结论

**算法函数中的常熟可以忽略；**

**算法函数中最高次幂的常数因子可以忽略**

**算法函数中最高次幂越小，算法效率越高**

### 1.2 算法时间复杂度

#### 1.2.1 大O记法

**执行次数=执行时间**执行次数越多，执行时间越长，时间复杂度越高

用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。一般情况下，随着输入规模n的增大，T(n)增长最 慢的算法为最优算法。

基于我们对函数渐近增长的分析，推导大O阶 的表示法有以下几个规则可以使用：

**1.用常数1取代运行时间中的所有加法常数；**

**2.在修改后的运行次数中，只保留高阶项；**

**3.如果最高阶项存在，且常数因子不为1，则去除与这个项相乘的常数；**

#### 1.2.2 常见的大O阶

**1.线性阶**

一般含有非嵌套循环涉及线性阶，线性阶就是随着输入规模的扩大，对应计算次数呈直线增长，例如：

```java
public static void main(String[] args) {
    int sum = 0;
    int n=100;
    
    for (int i = 1; i <= n; i++) {
    	sum += i;
    }
    
    System.out.println("sum=" + sum);
}
```

上面这段代码，它的循环的时间复杂度为O(n),因为循环体中的代码需要执行n次

**2.平方阶**

一般嵌套循环属于这种时间复杂度

```java
public static void main(String[] args) {
    int sum=0,n=100;
    
    for (int i = 1; i <=n ; i++) {
        for (int j = 1; j <=n ; j++) {
        	sum+=i;
        }
    }
    
    System.out.println(sum);
}
```

上面这段代码，n=100，也就是说，外层循环每执行一次，内层循环就执行100次，那总共程序想要从这两个循环 中出来，就需要执行100*100次，也就是n的平方次，所以这段代码的时间复杂度是O(n^2).

**3.立方阶**

一般三层嵌套循环属于这种时间复杂度

```
public static void main(String[] args) {
    int x=0,n=100;
    for (int i = 1; i <=n ; i++) {
        for (int j = i; j <=n ; j++) {
            for (int j = i; j <=n ; j++) {
            	x++;
            }
        }
    }
    System.out.println(x);
}
```

上面这段代码，n=100，也就是说，外层循环每执行一次，中间循环循环就执行100次，中间循环每执行一次，最 内层循环需要执行100次，那总共程序想要从这三个循环中出来，就需要执行100100100次，也就是n的立方，所 以这段代码的时间复杂度是O(n^3). 

**4.对数阶**

 对数，属于高中数学的内容，我们分析程序以程序为主，数学为辅，所以不用过分担心。

```java
int i=1,n=100;
while(i<n){
	i = i*2;
}
```

由于每次i*2之后，就距离n更近一步，假设有x个2相乘后大于n，则会退出循环。由于是2^x=n,得到x=log(2)n,所 以这个循环的时间复杂度为O(logn); 

对于对数阶，由于随着输入规模n的增大，不管底数为多少，他们的增长趋势是一样的，所以我们会忽略底数。

![image-20211004220644661](E:\Computer\学习笔记\study-notes\study_note\算法\黑马数据结构与算法\数据结构与算法资料\image-20211004220644661.png)

![image-20211004220656673](E:\Computer\学习笔记\study-notes\study_note\算法\黑马数据结构与算法\数据结构与算法资料\image-20211004220656673.png)

**5.常数阶**

一般不涉及循环操作的都是常数阶，因为它不会随着n的增长而增加操作次数。例如：

```java
public static void main(String[] args) {
    int n=100;
    int i=n+2;
    System.out.println(i);
}

```

上述代码，不管输入规模n是多少，都执行2次，根据大O推导法则，常数用1来替换，所以上述代码的时间复杂度 为O(1)

 **下面是对常见时间复杂度的一个总结：**

![image-20211004221733416](E:\Computer\学习笔记\study-notes\study_note\算法\黑马数据结构与算法\数据结构与算法资料\image-20211004221733416.png)

他们的复杂程度从低到高依次为： 

 O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)

根据前面的折线图分析，我们会发现，从平方阶开始，随着输入规模的增大，时间成本会急剧增大，所以，我们的 算法，尽可能的追求的是O(1),O(logn),O(n),O(nlogn)这几种时间复杂度，而如果发现算法的时间复杂度为平方阶、 立方阶或者更复杂的，那我们可以分为这种算法是不可取的，需要优化。

#### 1.2.3 函数调用的时间复杂度分析

之前，我们分析的都是单个函数内，算法代码的时间复杂度，接下来我们分析函数调用过程中时间复杂度。

```java
public static void main(String[] args) {
    int n=100;
        for (int i = 0; i < n; i++) {
            show(i);
        }
    }

private static void show(int i) {
   System.out.println(i);
}
```

在main方法中，有一个for循环，循环体调用了show方法，由于show方法内部只执行了一行代码，所以show方法 的时间复杂度为O(1),那main方法的时间复杂度就是O(n)



```java
public static void main(String[] args) {
    int n=100;
    
    for (int i = 0; i < n; i++) {
    	show(i);
    }
}

private static void show(int i) {
    for (int j = 0; j < i; i++) {
    	System.out.println(i);
    }
}
```

在main方法中，有一个for循环，循环体调用了show方法，由于show方法内部也有一个for循环，所以show方法 的时间复杂度为O(n),那main方法的时间复杂度为O(n^2)



```java
public static void main(String[] args) {
    int n=100;
    show(n);
    
    for (int i = 0; i < n; i++) {
    	show(i);
    }
    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
        	System.out.println(j);
        }
    }
}

private static void show(int i) {
    for (int j = 0; j < i; i++) {
    	System.out.println(i);
    }
}
```

在show方法中，有一个for循环，所以show方法的时间复杂度为O(n),在main方法中，show(n)这行代码内部执行 的次数为n，第一个for循环内调用了show方法，所以其执行次数为n^2,第二个嵌套for循环内只执行了一行代码， 所以其执行次数为n^2,那么main方法总执行次数为n+n^2+n^2=2n^2+n。根据大O推导规则，去掉n保留最高阶 项，并去掉最高阶项的常数因子2，所以最终main方法的时间复杂度为O(n^2)

#### 1.2.4 最坏情况

从心理学角度讲，每个人对发生的事情都会有一个预期，比如看到半杯水，有人会说：哇哦，还有半杯水哦！但也 有人会说：天哪，只有半杯水了。一般人处于一种对未来失败的担忧，而在预期的时候趋向做最坏的打算，这样即 使最糟糕的结果出现，当事人也有了心理准备，比较容易接受结果。假如最糟糕的结果并没有出现，当事人会很快 乐。 

算法分析也是类似，假如有一个需求： 

有一个存储了n个随机数字的数组，请从中查找出指定的数字。

```java
public int search(int num){
    int[] arr={11,10,8,9,7,22,23,0};
    
    for (int i = 0; i < arr.length; i++) {
        if (num==arr[i]){
        	return i;
        }
    }
    
    return -1;
}
```

**最好情况：** 查找的第一个数字就是期望的数字，那么算法的时间复杂度为O(1) 

**最坏情况：** 查找的最后一个数字，才是期望的数字，那么算法的时间复杂度为O(n) 

**平均情况：** 任何数字查找的平均成本是O(n/2) 最坏情况是一种保证，在应用中，这是一种最基本的保障，即使在最坏情况下，也能够正常提供服务，所以，除非 特别指定，我们提到的运行时间都指的是最坏情况下的运行时间。

## 2. 算法的空间复杂度分析

计算机的软硬件都经历了一个比较漫长的演变史，作为为运算提供环境的内存，更是如此，从早些时候的512k,经 历了1M，2M，4M...等，发展到现在的8G，甚至16G和32G，所以早期，算法在运行过程中对内存的占用情况也是 一个经常需要考虑的问题。我么可以用算法的空间复杂度来描述算法对内存的占用。

































